<div>
<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;padding-bottom:1rem;box-shadow:0 8px 17px 0 rgba(76,124,226,.2), 0 6px 20px 0 rgba(49,115,211,.19)">
<h4 class="margin-top:5rem;"><span style="font-weight:600">PHP 版本</span></h4>
</div>

<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;">
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。</span>
        </p>
    </div>
    <p>
        <br>
        到目前为止（2018-01-19），PHP 7.2 已经发布快两个月了。
        <br><br>
        7.0 以下版本已进入 LTS 养老末期，使用低版本的 PHP 意味着没有官方的安全维护，
        <br><br>
        也无法使用新特性和更快的速度（例如 PHP 内置加密操作 PASSWORD_HASH() 仅支持 PHP >= 5.5 ，
        <br><br>
        和大多数软件一样，PHP 通常会提供 LTS 长期支持和维护，
        <br><br>
        但是因为无法知道安全补丁的版本号，不像 Windows 操作系统一样，安全补丁有据可查，
        这会使得产品的安全性大大降低。
        <br><br>
        因此，如果你是新开的项目，请使用 PHP 最新版本，而过旧的项目也要尝试重构更新，
    </p>
</div>


<br>
<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;padding-bottom:1rem;box-shadow:0 8px 17px 0 rgba(76,124,226,.2), 0 6px 20px 0 rgba(49,115,211,.19)">
    <h4><span style="font-weight:600">依赖管理</span></h4>
</div>

<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;">
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>人生苦短，我用 Composer</span>
        </p>
    </div>
    <p>
        <br>
        <a href="https://getcomposer.org/" target="_black" rel="noopener noreferrer">Composer</a>
        在 PHP 生态中是重要的一环，大部分的扩展包都是通过 Composer 进行管理。
        <br><br>
        如果你是手动下载扩展包并进行手动加载，那么在大型应用上，你无法检测某个框架是否过时，
        <br><br>
        也无法知晓某个框架的重大安全漏洞并及时更新到最新版本，过老的版本是非常不安全的。
    </p>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>Composer 安装、配置及使用请参考本书 第二章：2.3 开发环境搭建。</span>
        </p>
    </div>
</div>

<br>
<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;padding-bottom:1rem;box-shadow:0 8px 17px 0 rgba(76,124,226,.2), 0 6px 20px 0 rgba(49,115,211,.19)">
    <h4><span style="font-weight:600">HTTPS 和浏览器安全</span></h4>
</div>

<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;">
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>HTTPS，一种通过计算机网络进行安全通信的传输协议。</span>
        </p>
    </div>
    <p>
        <br>
        在 2018 年，所有现代安全的浏览器已经不在接受 HTTP，用户打开 HTTP 协议的网站时，
        <br><br>
        浏览器会警告该网站的连接不安全。
        <br><br>
        不过你可以从各大云厂商免费的申请一个 TLS 证书，
        或者使用 
        <a href="https://letsencrypt.org/" target="_blank" rel="noopener noreferrer">Let's Encrypt certificate authority</a>。
    </p>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                因为本书使用的是 宝塔 服务器面板，不需要手动配置证书，所以不会详细涉及此部分内容。
            </span>
        </p>
    </div>
</div>

<br>
<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;padding-bottom:1rem;box-shadow:0 8px 17px 0 rgba(76,124,226,.2), 0 6px 20px 0 rgba(49,115,211,.19)">
    <h4><span style="font-weight:600">开发安全的 PHP 程序</span></h4>
</div>

<div style="padding-left:2rem;padding-right:2rem;padding-top:1rem;">
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>避免 PHP 程序存在 SQL 注入。</span>
        </p>
    </div>
    <p>
        <br>
        如果你是自己编写 SQL 代码，
        请确保使用prepared语句，
        <br><br>
        并且从网络或文件系统提供的信息都作为参数传递，
        而不是字符串拼接的形式。
        <br><br>
        此外，确保你没有使用 
        <a href="https://stackoverflow.com/questions/134099" target="_blank" rel="noopener noreferrer">模拟的 prepared 语句</a> 。
    </p>
    <br> 
    <h5>/* 错误实例： */ </h5>
    <div style="background-color:rgba(255, 0, 0, 0.1);color:#000;border-left:solid 3px #f44336;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                $query = $pdo->query("SELECT * FROM users WHERE username = '" . $_GET['username'] . "'");
            </span>
        </p>
    </div>
    <br>
    <h5>/* 应该这样做： */ </h5>
    <div style="background-color:rgba(0, 0, 0, 0.1);color:#000;border-left:solid 3px #009688;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                $results = $easydb->row("SELECT * FROM users WHERE username = ?", $_GET['username']);
            </span>
        </p>
    </div>
    <br>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>文件上传处理</span>
        </p>
    </div>
    <p>
        <br>
        接受未知来源的问题，意味着这些文件可能恶意攻击服务器，
        <br><br>
        请保证服务器文件权限不超过 775，
        <br><br>
        上传的新文件应该是 只读或读写，
        <br><br>
        不要在网站根目录保存文件，
        <br><br>
        同大多数 PHP 框架一样，不在根目录运行 index.php 
        目的是为恶意代码提供最少的执行环境，
        <br>
        例如：
    </p>
    <div style="background-color:rgba(0, 0, 0, 0.1);color:#000;border-left:solid 3px #009688;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                /var/www/example.com-uploaded/
            </span>
        </p>
    </div>
    <p>
        或者直接将文件往下移动一个层级
    </p>
    <div style="background-color:rgba(0, 0, 0, 0.1);color:#000;border-left:solid 3px #009688;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                /var/www/example.com/public
            </span>
        </p>
    </div>
    <br>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>跨站请求伪造</span>
        </p>
    </div>
    <p>
        <br>
        跨站请求伪造（CSRF）是一种混淆的代理攻击，通过诱导用户的浏览器代表攻击者执行恶意的 HTTP 请求（使用的是该用户的权限）。
        <br><br>
        首先使用 HTTPS，没有 HTTPS 的话，任何保护都是脆弱的，因为所有数据都是明文传输。
        <br><br>
        如果你是用的是现代 PHP 框架，请在框架中开启 CSRF 验证
        <br><br>
        如果你是原生用户，只需要：
        <ul>
            <li>
                增加基本的 Challenge-response authentication。
            </li>
            <ul>
                <li>
                    为每个表单添加一个隐藏的表单属性。
                </li>
                <li>
                    填充一个密码安全的随机值（称为令牌）。
                </li>
                <li>
                    验证是否提供了隐藏的表单属性，以及是否匹配上期望值。
                </li>
            </ul>
        </ul>
    </p>
    <br>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>密码散列</span>
        </p>
    </div>
    <p>
        <br>
        安全的密码存储曾经是一个激烈争论的话题，但现在实现起来相当微不足道，特别是在 PHP 中：
    </p>
    <div style="background-color:rgba(0, 0, 0, 0.1);color:#000;border-left:solid 3px #009688;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                $hash = \password_hash($password, PASSWORD_DEFAULT);
                <br>
                if (\password_verify($password, $hash)) {
                    <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Authenticated.
                    <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (\password_needs_rehash($hash, PASSWORD_DEFAULT)) {
                        <br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Rehash, update database.
                        <br>
                &nbsp;&nbsp;&nbsp;&nbsp;}
                    <br>
                }
            </span>
        </p>
    </div>
    <p>
        <br>
        你甚至不需要知道在后台使用什么算法，因为如果你使用最新版本的 PHP ，你也将使用当前最新的技术，用户的密码将会自动进行升级（只要有新的默认算法可用）。
    </p>
    <br>
    <div style="background-color:rgba(255, 0, 0, 0.1);color:#000;border-left:solid 3px #f44336;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                无论你做什么，都不要做 WordPress 所做的事情
            </span>
        </p>
    </div>
    <p>
        <br>
        WordPress 并不使用 bcrypt 来储存密码，而是使用 MD5，
        <br><br>
        要理解为什么，首先查看 
        <a href="https://github.com/WordPress/WordPress/blob/c1e4d2535070069a2dd51e4da04fbf9c5e86b558/wp-includes/class-phpass.php#L233-L254" target="_black" rel="noopener noreferrer">
            这个代码片段
        </a> 
        以及 
        <a href="https://github.com/WordPress/WordPress/blob/c1e4d2535070069a2dd51e4da04fbf9c5e86b558/wp-includes/class-phpass.php#L121-L164" target="_black" rel="noopener noreferrer">
            这一个
        </a>
        <br><br>
        如果 
        <span style="color:#f44336">$this->portable_hashes</span> 
         设置为TRUE，则会调用 
        <span style="color:#f44336">$this->crypt_private()</span> 
        （ 使用8192次MD5）。
        <br><br>
        因此，<span style="color:#f44336">HashPassword</span> 可以大大简化为以下片段：
    </p>
    <div style="background-color:rgba(255, 0, 0, 0.1);color:#000;border-left:solid 3px #f44336;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                function HashPassword($password)<br>
                {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if ( strlen( $password ) > 4096 ) {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return '*';<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;/* these steps are skipped */<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;$random = $this->get_random_bytes(6);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;$hash =<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;$this->crypt_private($password,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;$this->gensalt_private($random));<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if (strlen($hash) == 34)<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return $hash;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return '*';<br>
                }<br>
            </span>
        </p>
    </div>
    <br>
    <div style="background-color:#4B515D;color:#fff;border-left:solid 3px #4285F4;padding-top:1rem;padding-bottom:1rem;">
        <p style="margin-left: 1rem;margin-right: 1rem;">
            <span>
                避免的事情
            </span>
        </p>
    </div>
    <p>
        <br>
        <ul>
            <li>
                不要使用 <span style="color:#9e9e9e ">mcrypt</span>。
                这是一个十多年来没有开发出来的密码学库。
            </li>
            <li>
                不要使用 JOSE（JWT，JWS，JWE），这是一套互联网标准，它编纂了一系列容易出错的密码设计。
                尽管由于某种原因，被写入了标准，也吸引了很多传道人。
            </li>
            <li>
                避免使用 RSA，改用 libsodium 。如果你必须使用 RSA ，请确保指定 OAEP 填充。
            </li>
        </ul>
    </p>
</div>
</div>

